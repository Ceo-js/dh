

<!DOCTYPE html>
<html lang="pt-br">
   <head>
      <title></title>
      
      <link rel="icon" href="src/pix/logo.svg" type="svg+xml">
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
      <link rel="stylesheet" href="https://globals.onrender.com/global-dh.css">
      <script src="https://globals.onrender.com/global-dh.js" defer></script>
   </head>
   <body>

      <top-bar>
         Módulo:  6 - Express
      </top-bar>

      <modulo n="6">

         <padroes-mvc>

            <introducao>
               <h4>Introdução ao Módulo</h4>
               <display>
                  <h1>Introdução ao Módulo</h1>
                  <p>
                     Até agora, vimos uma pequena introdução ao mundo do Express quando cobrimos HTML e CSS, mas agora é a hora de nos aprofundarmos nesse universo.
                  </p>
                  <p>
                     Neste novo módulo, vamos entender todo o potencial que o Express tem para oferecer e vamos trabalhar com um padrão de desenho conhecido como MVC. Isso nos permitirá organizar nosso trabalho de uma forma muito mais lógica e funcional.
                  </p>
                  <p>
                     Vamos estudar o esquema que um servidor usa ao receber uma solicitação, bem como cada um dos componentes que fazem dos arquivos back-end um sistema completo, forte e robusto, capaz de suportar toda a lógica de nossos sistemas web.
                  </p>
                  <iframe src="https://view.genial.ly/62a0adceb32b620010a661bb" frameborder="0"></iframe>
                  <hr>
                  <h2>O que vamos ver nesta aula</h2>
                  <p>
                     Essa aula é uma daquelas que são pilares fundamentais do curso, pois vamos começar entendendo o que é o padrão MVC. Isso nos dará a base para entrar nos controladores, que são uma parte fundamental do padrão MVC.
                  </p>
                  <p>
                     Da mesma forma, e com o único objetivo de modularizar muito mais a nossa aplicação, vamos voltar aos conceitos de rotas, entendendo bem o que são rotas parametrizadas. Ao mesmo tempo, vamos estruturar um sistema de roteamento completo, para que nossa aplicação seja construída de forma perfeita.

                  </p>
                  <p></p>
                  <p>E como cereja do bolo, finalizamos esta aula com uma ótima ferramenta (opcional) chamada express-generator, que nos permitirá gerar a estrutura de nossa aplicação de uma forma muito mais rápida e organizada.</p>
                  <p>
                     Portanto, sem mais nada a dizer, vamos entrar neste mundo!
                  </p>
               </display>
            </introducao>
            
            <introducao-ao-mvc>
               <h4>Introdução ao MVC</h4>
               <display>
                  <h1>Você está aqui!</h1>
                  <img src="./Assets/Introdução ao MVC - Você está aqui.jpg" alt="">
                  <p>
                     O Controlador (ou Controller) é o que conhecemos tradicionalmente como: a ponte entre a View e a Model.
                  </p>
                  <p>
                     Este se encarregará de atender os pedidos feitos pelo cliente através da View, de estabelecer uma comunicação direta com a Model para solicitar informações armazenadas no banco de dados e de voltar com a informação, mandando-a diretamente para a View, para que esta última possa mostrá-la facilmente para a pessoa que visita nossa aplicação web.
                  </p>
                  <p>
                     Embora no padrão MVC os três componentes sejam de suma importância, o Controller é quem toma um protagonismo importante. Só ele sabe atender aos pedidos, solicitar informação ao banco de dados (se for necessário), definir qual será a resposta que tem que dar ante um determinado pedido.
                  </p>
                  <video src="./Assets/Introdução ao MVC.mp4"></video>
                  <iframe src="./Assets/Introdução ao MVC.html" frameborder="0"></iframe>

                  <sub>
                     Os design patterns propõem uma forma de trabalhar na solução de problemas
específicos. Eles são usados ??como uma boa prática que facilita o trabalho em
equipe, permitindo que critérios e abordagens sejam unificados.
                  </sub>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>EXPRESS_intro_a_MVC</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">O que é o Design Pattern?</p>
                        </header>
                        <choices>
                           <label choice="gs">
                              <input type="radio">
                              <t>Conjunto de regra que definem a arquitetura de um sistema.</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Conjunto de bibliotecas que definem a arquitetura de um sistema</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Conjunto de elementos separados que definem um sistema</t>
                           </label>
                        </choices>
                        <res>
                           <p>Muito bem! Como você disse, eles são um conjunto de regras. Podem ser vistos como uma proposta de trabalho, um esquema sugerido.</p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="2">MVC significa...</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>Model-Value-Control</t>
                           </label>
                           <label choice="gsd">
                              <input type="radio">
                              <t>Model-View-Controller</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Missing-Value-Coder</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Massive-View-Contrller</t>
                           </label>
                        </choices>
                        <res>
                           <p>Model-View-Controller</p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="3">No MVC</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>O model fala com a view e a view com o controller</t>
                           </label>
                           <label choice="fgds">
                              <input type="radio">
                              <t>A view fala com o controller e o controller com o model</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>O controller fala com a view e a view com o model</t>
                           </label>
                        </choices>
                        <res>
                           <p>Isso aí! Vamos para o próximo!</p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="4">Quais das seguintes frases estão corretas?</p>
                        </header>
                        <choices>
                           <label choice="gd">
                              <input type="checkbox">
                              <t>A view representa a interface gráfica, parte vista pelo usuário</t>
                           </label>
                           <label choice="gd">
                              <input type="checkbox">
                              <t>O model representa os dados ou entidades do meu sistema</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>A view representa uma forma de acessar o model</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>O controller controla os dados.</t>
                           </label>
                           <label choice="gd">
                              <input type="checkbox">
                              <t>O model contém a lógica do negócio</t>
                           </label>
                           <label choice="gd">
                              <input type="checkbox">
                              <t>O controller passa informações para a view</t>
                           </label>
                        </choices>
                        <res>
                           <p>Muito bom!</p>
                        </res>
                     </home>
                  </quiz>
               </display>
            </introducao-ao-mvc>
            
            <controllers>
               <h4>Controllers</h4>
               <display>
                  <h1>Controllers</h1>
                  <img src="./Assets/Introdução ao MVC - Você está aqui.jpg" alt="">
                  <p>
                     O Controlador (ou Controller) é o que conhecemos tradicionalmente como: a ponte entre a View e a Model.
                  </p>
                  <p>Este se encarregará de atender os pedidos feitos pelo cliente através da View, de estabelecer uma comunicação direta com a Model para solicitar informações armazenadas no banco de dados e de voltar com a informação, mandando-a diretamente para a View, para que esta última possa mostrá-la facilmente para a pessoa que visita nossa aplicação web.</p>
                  <p>
                     Embora dentro do padrão MVC os três componentes sejam de suma importância, o Controller é quem toma um protagonismo importante. Só ele sabe atender aos pedidos, solicitar informação ao banco de dados (se for necessário), definir qual será a resposta que tem que dar ante um determinado pedido.
                  </p>
                  <video src="./Assets/Controllers.mp4"></video>
                  <iframe src="./Assets/Os Controladores.html" frameborder="0"></iframe>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>EXPRESS_controllers</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">O que é um controller?</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>É quem cuida da visualização dos dados</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>É a parte do sistema que acessa o banco de dados</t>
                           </label>
                           <label choice="gs">
                              <input type="radio">
                              <t>É a parte do sistema que mantém a lógica do negócio</t>
                           </label>
                        </choices>
                        <res>
                           <p>Justamente isso! O controller é quem mantém a loja de negício.</p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="2">Tratando-se de controller, qual das frases seguintes são corretas?</p>
                        </header>
                        <choices>
                           <label choice="gsdfs">
                              <input type="checkbox">
                              <t>Manda informações para a view</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>Não mantem relação com a view</t>
                           </label>
                           <label choice="gsdfs">
                              <input type="checkbox">
                              <t>Utiliza models para levantar informações</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>Não tem nenhuma relação com os models</t>
                           </label>
                        </choices>
                        <res>
                           <p>Muito bem :). Podemos ver o controller como um intermediário, um interlocutor entre a view e os models.</p>
                        </res>
                     </home>
                  </quiz>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>Express_MVC_controllers_análise_de_caso</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">
                              Recebemos um pedido para projetar um sistema que permita gerenciar o estoque de um quiosque.
                              <br>
                              Decidimos aplicar nosso conhecimento no NODE e abordar o projeto usando essa tecnologia. Eles nos informaram que devemos manter um registro dos clientes como se fossem usuários. Devemos registrar dados como nome, ID e produtos que compraram. Também devemos manter os detalhes dos produtos como preços, estoque e registrar as vendas destes produtos aos clientes.
                                 <br>
                              Quando configuramos o sistema, começamos a nos perguntar de quais controllers acreditamos ser necessários.
                           </p>
                           <p>Vamos começar!</p>
                           <p>Qual dos seguintes controllers poderiam estar no sistema?</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>PrecosController</t>
                           </label>
                           <label choice="gsd">
                              <input type="radio">
                              <t>ProdutosController</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>ComandasController</t>
                           </label>
                        </choices>
                        <res>
                           <p>
                              Excelente. O controller ProdutosController é o que precisamos para lidar com todos os diferentes produtos, e também pode lidar com muitos detalhes deles, como aumentar preço preço, alterar descrição, etc.
                           </p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="2">Quais desses controllers poderiam estar no sistema?</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>RotasController</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>TelaController</t>
                           </label>
                           <label choice="gds">
                              <input type="radio">
                              <t>EstoqueController</t>
                           </label>
                        </choices>
                        <res>
                           <p>
                              Muito bem. É muito bom pensar que precisaríamos de um controller para o estoque dos produtos. Embora possamos ter essa responsabilidade no ProdutosController, sendo algo muito importante para os negócios, pode ser uma boa decisão lidar com toda essa lógica separadamente. Por outro lado, o TelaController não é, por si só, necessário, pois, a priori, parece ter uma relação maior com a visualização das coisas e isso faz parte da view. Enfim, controlar as rotas não é uma tarefa para um controlleres.
                           </p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="3">Quais dos controllers poderiam estar no sistema?</p>
                        </header>
                        <choices>
                           <label choice="sdgs">
                              <input type="radio">
                              <t>ClientesController</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>RegistrosController</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>CaloteirosController</t>
                           </label>
                        </choices>
                        <res>
                           <p>Perfeito Nesse caso, podemos inferir que CaloteiroController é um caso de cliente específico, portanto não é necessário criar uma lógica completamente diferente e específica para eles.</p>
                        </res>
                     </home>
                  </quiz>

                  <exercicio>
                     <display>
                        <h2>Exercício 1</h2>
                        <p>
                           Começa um novo e lindo dia e chega um novo pedido do cliente. Você está trabalhando num controller de um carrinho de compras de um e-commerce. Te pediram para que, quando um cliente adicionasse um produto ao carrinho, ele retorna-se uma mensagem 'Item Adicionado'.
                        </p>
                        <p>
                           O líder técnico em sua área informa que, para atender a esse requisito, você deve modificar a função addItem para receber os parâmetros req e res. Dito isto, o líder técnico se afasta misteriosamente, dizendo que você deve analisar como retornar a mensagem 'Item Adicionado' utilizando os dois parâmetros: req e res.
                        </p>
                        <co-de>
                           let CarrinhoController = {
                              removeItem: function(){},
                              getItem: function(){},
                              addItem: function( req, res ){
                                 res.send( console.log( "Item Adicionado" ) );
                              }
                           };
                           
                           module.exports = CarrinhoController;
                        </co-de>
                     </display>
                  </exercicio>
                  
                  <exercicio>
                     <display>
                        <h2>Exercício 2</h2>
                        <p>
                           Você criou um controller para lidar com o carrinho de compras (CarrinhoController). Você já estava indo embora quando o líder do projeto percebeu que não existe uma rota configurada para o seu controller! Você bem que tentou, mas ele te alcançou antes de você tocar na maçaneta! Não teve jeito.
                        </p>
                        <p>
                           Crie uma rota get para o endereço raíz (/) passando como parâmetro :item. Essa rota deve redirecionar para o método addItem do CarrinhoController 
                        </p>
                        <co-de>
                           let express = require('express')
                           let router = express.Router();
                           let CarrinhoController = require('../controllers/CarrinhoController')
                           
                           router.get( "/:item", CarrinhoController.addItem );
                           
                           module.exports = router
                        </co-de>
                     </display>
                  </exercicio>
                  
               </display>
            </controllers>
            
            <revisao-de-rotas>
               <h4>Revisão de Rotas</h4>
               <display>
                  <h1>Revisão de rotas</h1>
                  <p>
                     É muito importante na construção de um serviço web ou de um site, definirmos claramente quais serviços um cliente pode acessar.
                  </p>
                  <p>
                     Para isso, temos que definir os caminhos no nosso servidor, ou seja, as rotas.
                  </p>
                  <p>Vamos ver como podemos fazer isso?</p>
                  <iframe src="./Assets/Revisão de rotas.html" frameborder="0"></iframe>
               </display>
            </revisao-de-rotas>
            
            <rotas-parametrizadas>
               <h4>Rotas parametrizadas</h4>
               <display>
                  <h1>Rotas parametrizadas</h1>
                  <p>
                     Imagine que temos 2000 produtos no nosso site e queremos mostrar os detalhes de cada um deles. Para isso, criamos 2000 rotas diferentes, uma para cada produto. Será que isso seria viável? Com certeza não!
                  </p>
                  <p>
                     Pensando em resolver esse problema, o Express nos permite trabalhar com rotas dinâmicas.
                  </p>
                  <p>Uma rota dinâmica é aquela que mostra uma informação ou outra dependendo de determinados critérios. Diferente das rotas estáticas, aquelas que estávamos trabalhando até o momento.</p>
                  <p>Veremos as configurações necessárias que devemos implementar para poder dar esse dinamismo às nossas rotas.</p>
                  <video src="./Assets/Rotas parametrizadas.mp4"></video>
                  <iframe src="./Assets/Rotas parametrizadas.html" frameborder="0"></iframe>

                  <exercicio>
                     <display>
                        <h2>Exercício 1</h2>
                        <p>
                           Vamos listar todas as séries!
                        </p>
                        <p>
                           Temos uma lista de muitas séries armazenadas na variável series. O seu trabalho será criar um caminho que aponte para o endereço "/series" e devolva todas elas.
                        </p>
                        <co-de>
                           const express = require('express');
                           const app = express();
                           
                           app.get( '/series', function(req, res) {
                               res.send(series);
                           })
                        </co-de>
                     </display>
                  </exercicio>
                  
                  <exercicio>
                     <display>
                        <h2>Exercício 2</h2>
                        <p>
                           Vamos ver como configurar a nossa primeira rota parametrizada com o Express.
                           <br>
                           Queremos que você crie uma rota que aponte para "/serie" e que ela, por sua vez, receba um número. Esse número vai representar a identificação da série que tentamos visualizar. Portanto, a rota deve retornar apenas a série que corresponde ao id que veio pelo parâmetro.
                           <br></br>
                           Um exemplo de como seria a rota: http://localhost/serie/3
                           <br>
                           Lembre-se que a variável da series já foi declarada, contem um array de objetos e você pode usá-la apenas escrevendo seu nome. Clique em Details para ver uma informação adicional.
                        </p>
                        <details>
                           <summary>Saiba mais!</summary>
                           <display>
                              <pre>
const series = [
   {
   id: 1,
   nome: 'Irmão do Jorel'
   },
   {
   id: 2,
   nome: 'Um maluco no pedaço'
   }
]
                              </pre>
                           </display>
                        </details>
                        <co-de>
                           const express = require('express');
                           const app = express();
                           
                           app.get( "/serie/:id", (req, res ) => {
                              let { id } = req.params;
                        
                              res.send(
                                 series.find( v => {
                                    if( v.id == id) {
                                       return v;
                                    }
                                    } ) 
                              );   
                           } );     
                        </co-de>
                     </display>
                  </exercicio>
                  
               </display>
            </rotas-parametrizadas>
            
            <sistema-de-roteamento>
               <h4>Sistema de roteamento</h4>
               <display>
                  <h1>Sistema de roteamento</h1>
                  <p>
                     Toda aplicação que busque ser escalável, precisa ter componentes modularizados. E as rotas não ficam de fora deste processo. Por isso, quando encaramos a implementação das rotas que a nossa aplicação web terá, é conveniente pensar em pequenas "entidades" de funcionamento, mais que em uma estrutura "monolítica".
                  </p>
                  <p>
                     Para esse objetivo, o Express nos dá a possibilidade de criar diferentes arquivos que administrem as possíveis rotas de nosso site. Sempre tenha em mente que o importante, nesta "atomização", é a organização de nossos arquivos dentro de nosso projeto. Tudo com o objetivo de manter mais estável nosso desenvolvimento.
                  </p>
                  <p>
                     Desta forma, podemos concluir então que o sistema de roteamento dentro de um projeto de Express não é nada além de uma modularização das rotas de nossa aplicação, para que as mesmas permaneçam divididas e organizadas, dependendo de suas funcionalidades.
                  </p>
                  <p>
                     Veremos um pouco mais a fundo como é que isso funciona na prática!
                  </p>
                  <video src="./Assets/Sistema de roteamento.mp4"></video>
                  <iframe src="./Assets/Sistema de roteamento.html" frameborder="0"></iframe>

                  <exercicio>
                     <display>
                        <h2>Exercício 1</h2>
                        <p>Vamos modular as rotas para as séries.</p>
                        <p>
                           Queremos que o arquivo series.js processe TODOS os pedidos do recurso. Como primeiro passo pedimos que você crie a variável express e armazene o módulo express nela.
                           <br><br>
                           Então, você deve criar a variável router e armazenar nela a execução do método que nos permite gerenciar um sistema de rotas. 
                        </p>
                        <co-de>
                           const express = require('express');
                           const router = express.Router();
                        </co-de>
                     </display>
                  </exercicio>
                  
                  <exercicio>
                     <display>
                        <h2>Exercício 2</h2>
                        <p>No script deste exercício já definimos as rotas relacionadas com os request das informações contidas no array de séries.</p>
                        <p>
                           O seu trabalho será tornar esse código "visível" para assim podermos acessá-lo a partir de outros arquivos.

                           <br></br>
                           Lembra como fazer isso? Quem é responsável pelo compartilhamento de todos esses caminhos definidos?
                        </p>
                        <co-de>
                           const express = require('express');
                           const router = express.Router();
                           
                           router.get('/', (req,res) => {
                           });
                           router.get('/:genero', (req,res) => {
                           });
                           router.get('/criar', (req,res) => {
                           });
                           
                           module.exports = router;
                        </co-de>
                     </display>
                  </exercicio>
                  
                  <exercicio>
                     <display>
                        <h2>Exercício 3</h2>
                        <p>A partir do arquivo index.js queremos acessar o arquivo series.js. Seu trabalho será solicitar esse módulo e armazená-lo na variável rotasSeries. Finalmente, queremos que esse módulo se encarregue de tratar de todos as solicitações que venham de séries. </p>
                        <p>
                           Antes de começarmos... Tenha em mente que estamos lidando com um sistema de rotas e organização de diretórios é MUITO importante, portanto o arquivo series.js é armazenado na pasta de routes. 
                        </p>
                        <co-de>
                           const express = require('express');
                           const app = express();
                           const rotasSeries = require("./routes/series");
                           
                           app.use( "/series", rotasSeries );
                           
                        </co-de>
                     </display>
                  </exercicio>
                  
               </display>
            </sistema-de-roteamento>
            
            <estrutura-de-arquivos>
               <h4>Estrutura de arquivos</h4>
               <display>
                  <h1>Estrutura de arquivos</h1>
                  <p>
                     Até agora, sabemos que temos que trabalhar com rotas. Controladores e vistas já estão sendo parte natural de nosso processo de desenvolvimento, mas como podemos começar a organizar nossos arquivos?
                  </p>
                  <p>
                     Esta pergunta não tem uma resposta 100% definitiva, mas podemos pensar em um jeito padrão que nos permita organizá-los da melhor maneira possível. É por isso que abaixo compartilhamos uma estrutura de arquivos sugerida para otimizar muito mais o processo de programar.
                  </p>
                  <h5>Estrutura de arquivos recomendada:</h5>
                  <co-de>
                     ??? node_modules ? Pasta de módulos locais do projeto

                     ??? public ? Pasta de arquivos públicos
                     
                     ??? src ? Pasta de arquivos funcionais da aplicação
                     
                     ?   ??? controllers
                     
                     ?       ??? (aqui vão os controladores)
                     
                     ?   ??? views
                     
                     ?       ??? (aqui vão as vistas)
                     
                     ?   ??? routes
                     
                     ?       ??? (aqui vão as rotas)
                     
                     ??? app.js ? Arquivo de entrada do projeto
                     
                     ??? package.json
                     
                     ??? package-lock.json
                  </co-de>
                  <p>
                     Com esta estrutura, podemos separar por responsabilidades cada um dos componentes da nossa aplicação e, desta maneira, gerir melhor o nosso trabalho e o da equipe. Em caso de ter de repartir as tarefas, estas já poderão ser divididas por funcionalidade. Assim, teremos a tranquilidade de que duas pessoas não vão trabalhar no mesmo arquivo.
                  </p>
                  <iframe src="./Assets/Como organizar seus arquivos.html" frameborder="0"></iframe>
                  <iframe src="https://view.genial.ly/6231e35abb04e60018360159" frameborder="0"></iframe>
               </display>
            </estrutura-de-arquivos>
            
            <express-generator>
               <h4>Bônus: express-generator</h4>
               <display>
                  <h1>Bônus: express-generator</h1>
                  <p>
                     Certamente em algum momento você se perguntou: eu realmente tenho que fazer tudo isso manualmente? Embora a resposta (na maioria das vezes) seja um sonoro SIM, já que isso permite que você tenha mais controle sobre o que está fazendo, às vezes um pouco de ajuda não faz mal. E é aí que encontramos ferramentas como o express-generator.
                  </p>
                  <p>
                     Express-generator, como o nome indica, é um gerador de projeto Express. O que isso significa? Basicamente, rodando um único comando no console, você terá um grande conjunto de arquivos e sua estrutura correspondente, prontos para uso.
                  </p>
                  <p>
                     Embora pareça INCRÍVEL, às vezes não é. Afinal, qualquer ferramenta que resolva "muitas" coisas para nós, por sua vez, está nos abstraindo do entendimento "do que está por baixo do capô".
                  </p>
                  <p>
                     Não é ruim usar esses tipos de ferramentas, mas o que eles resolvem você certamente conseguirá com alguns minutos de esforço e várias linhas de código.
                  </p>
                  <video src="./Assets/express-generator.mp4"></video>
                  <iframe src="./Assets/express-generator.html" frameborder="0"></iframe>
               </display>
            </express-generator>
            
            <ao-vivo>
               <h4>Para a aula ao vivo</h4>
               <display>
                  <h1>Para a aula ao vivo</h1>
                  <p>
                     Design patterns. Models, Views e Controllers. Rotas estáticas e rotas dinâmicas. E como um "bônus" uma ótima ferramenta chamada express-generator. Tudo isso era o que estávamos vendo nessa aula, que parece muito, mas realmente não é.
                  </p>
                  <p>
                     Antecipando nossa aula ao vivo, convidamos você a se preparar, pois como sempre, a ideia desse encontro é "arrasar" e tirar o máximo proveito dela.
                  </p>
                  <p>
                     Para fazer isso, podemos verificar internamente se conseguimos responder às seguintes questões de forma simples:
                  </p>
                  <ul>
                     <li>
                        <p>O que é um pattern design e para que serve?</p>
                     </li>
                     <li>
                        <p>O que a letra M se refere no padrão MVC?</p>
                     </li>
                     <li>
                        <p>Quem interage diretamente com as views?</p>
                     </li>
                     <li>
                        <p>Por que é recomendado implementar um sistema de roteamento em nossa aplicação?</p>
                     </li>
                     <li>
                        <p>Para que servem as rotas dinâmicas?</p>
                     </li>
                     <li>
                        <p>Se você tivesse que revisar o código de outra pessoa, como poderia identificar uma rota que recebe parâmetros?</p>
                     </li>
                     <li>
                        <p>Dentro do corpo do código de um controller, como podemos recuperar os parâmetros que chegam até nós através da rota?</p>
                     </li>
                     <li>
                        <p>Vale sempre a pena usar o express-generator?</p>
                     </li>
                  </ul>
                  <p>
                     Se você conseguiu responder com força às questões anteriores, relaxe, a gente se vê na aula ao vivo. Se, por outro lado, você demorou um pouco para obter as respostas e ainda tem algumas dúvidas, nós o convidamos a dar uma nova olhada nos tópicos vistos.
                  </p>
               </display>
            </ao-vivo>
            
            <padroes-mvc-ao-vivo>
               <h4>Padrões MVC [ao Vivo]</h4>
               <display>
                  <h1>Padrões de desenho MVC</h1>
                  <p>
                     Chegou a hora de começar a montar a roda MVC.
                  </p>
                  <p>
                     É importante ter em mente que com este padrão de design não só conseguiremos organizar muito mais nossos arquivos, mas também tornaremos nossos projetos mais escaláveis, porque nos dá a possibilidade de adicionar funcionalidades parciais que fazem parte de um ambiente de programação otimizado.
                  </p>
                  <p>
                     Nesta aula, em particular:
                  </p>
                  <ul>
                     <li>
                        <p>Vamos nos concentrar muito na parte "VC" do padrão. Bem, só começaremos a trabalhar nos modelos quando soubermos mais sobre bancos de dados;</p>
                     </li>
                     <li>
                        <p>Vamos estruturar nosso trabalho sob o esquema de rotas e controladores, e</p>
                     </li>
                     <li>
                        <p>Vamos gerar a estrutura de pastas ideal e entenderemos para onde as coisas devem ir.</p>
                     </li>
                  </ul>
                  <p>Portanto, sem mais a dizer, vamos colocar as mãos no código.</p>
                  <iframe src="./Assets/Padrão de desenho MVC.html" frameborder="0"></iframe>
                  <iframe src="./Assets/Design Pattern MVC - Prática integradora.pdf" frameborder="0"></iframe>

                  <h2>Arquivos para a prática MVC - zip</h2>
                  <p><a href="./Assets/arquivos-para-a-pratica-mvc (1).zip" download="">arquivos-para-a-pratica-mvc (1).zip</a></p>
                  <h2>Prática resolvida MVC - zip</h2>
                  <p><a href="./Assets/meu-porfolio-mvc-resolvido.zip" download="">meu-porfolio-mvc-resolvido.zip</a></p>

               </display>
            </padroes-mvc-ao-vivo>
            
         </padroes-mvc>
         
         <Views-com-ejs>
            
            <introducao-a-template-engine>
               <h4>O que vamos ver nessa aula</h4>
               <display>
                  <h1>O que vamos ver nessa aula</h1>
                  <p>
                     Nesta aula, aprenderemos como podemos gerar as views do seu projeto Express.
                  </p>
                  <p>
                     Trabalharemos pontualmente com um mecanismo de template chamado EJS (Embedded JavaScript). Não se assuste, o nome pode parecer estranho, mas é basicamente o mesmo que HTML... apenas um HTML mais poderoso.
                  </p>
                  <p>
                     Ao longo desta aula, aprenderemos:
                  </p>
                  <ul>
                     <li>
                        <p>O que é um template engine e para que ele serve.</p>
                     </li>
                     <li>
                        <p>Por que escolhemos trabalhar com o EJS.</p>
                     </li>
                     <li>
                        <p>Como instalar o EJS em nosso projeto Express.</p>
                     </li>
                     <li>
                        <p>Como criar views e fazer com que apareçam no navegador.</p>
                     </li>
                     <li>
                        <p>Como obter o máximo das ferramentas que o EJS nos oferece.</p>
                     </li>
                     <li>
                        <p>Como passar dados do controller para a view.</p>
                     </li>
                     <li>
                        <p>Como particionar essas partes do código HTML que frequentemente se repetem em todo o site.</p>
                     </li>
                  </ul>
                  <p>Então, sem mais demora, vamos ver este mundo interessante do EJS.</p>
                  <hr>
                  <h1>Introdução a Template Engine</h1>
                  <p>
                     O que é mecanismo de modelos? O que é um modelo?
                  </p>
                  <p>
                     Vamos por partes. Um modelo (ou um template) é um arquivo que possui uma estrutura HTML pré-definida, o que nos ajuda a gerar vários outros arquivos a partir desse original.
                  </p>
                  <p>
                     Por outro lado, um mecanismo de modelos (ou template engine) é aquele que nos permite gerar um template em si mesmo, para que nossa aplicação possa usá-la.
                  </p>
                  <p>
                     Existem vários templates engines, mas particularmente nessa aula, veremos o EJS, já que seu uso e implementação são realmente bem simples (mas isso não quer dizer que seja menos poderoso).
                  </p>
                  <p>
                     Outra característica de um template engine é que ele nos permite gerar arquivos dinâmicos, que contenham informação vinda dos controllers.
                  </p>
                  <p>
                     Graças a essa característica, e com apenas alguns arquivos, vamos poder mostrar toda aquela informação armazenada no nosso banco de dados.
                  </p>
                  <p>Vamos lá?</p>
                  <video src="./Assets/Introdução a Template Engine.mp4"></video>
                  <iframe src="./Assets/Introdução a Template Engine.html" frameborder="0"></iframe>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>Questionário: Introdução a Template Engine</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">
                              O que um template engine permite?  
                              <br>
                              (mais de uma alternativa podem estar corretas)
                           </p>
                        </header>
                        <choices>
                           <label choice="sd">
                              <input type="checkbox">
                              <t>Que os arquivos HTML sejam dinâmicos</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>Ter múltiplos arquivos HTML para a mesma view</t>
                           </label>
                           <label choice="sd">
                              <input type="checkbox">
                              <t>Reutilizar código HTML</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>Reutilizar o código do modelo MVC</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="2">Qual extensão os arquivos HTML devem ter para que o EJS consiga processa-los?</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>.html</t>
                           </label>
                           <label choice="fsassd">
                              <input type="radio">
                              <t>.ejs</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>.htmlejs</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>.ejshtml</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                  </quiz>
               </display>
            </introducao-a-template-engine>
            
            <installation-e-implementacao>
               <h4>Instalação e Implementação</h4>
               <display>
                  <h1>Instalação e Implementação</h1>
                  <p>
                     Agora que entendemos o que é um mecanismo de modelos e as vantagens de trabalhar com um dentro de nossos projetos, vamos nos aprofundar um pouco mais sobre e entender como é simples o processo de instalação e implementação do mesmo.
                  </p>
                  <p>
                     Um par de linhas no console, e outro par de linhas nos arquivos Javascript e pronto: tudo estará funcionando!
                  </p>
                  <video src="./Assets/Instalação e Implementação.mp4"></video>
                  <iframe src="./Assets/Instalação e Implementação.html" frameborder="0"></iframe>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>Questionário: Introdução a Template Engine</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">
                              O que um template engine permite?  
                              <br>
                              (mais de uma alternativa podem estar corretas)
                           </p>
                        </header>
                        <choices>
                           <label choice="ds">
                              <input type="checkbox">
                              <t>Que os arquivos HTML sejam dinâmicos</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>Ter múltiplos arquivos HTML para a mesma view</t>
                           </label>
                           <label choice="ds">
                              <input type="checkbox">
                              <t>Reutilizar código HTML</t>
                           </label>
                           <label choice="">
                              <input type="checkbox">
                              <t>Reutilizar o código do modelo MVC</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                  </quiz>
               </display>
            </installation-e-implementacao>
            
            <primeira-view>
               <h4>Primeira View</h4>
               <display>
                  <h1>Primeira View</h1>
                  <p>
                     Você se lembra como funciona o fluxo MVC? Não? Vamos revisar um pouquinho…
                  </p>
                  <p>
                     As views se comunicam com os controllers e recebem a informação por eles recebida das models.
                  </p>
                  <p>
                     Para poder mostrar uma view no navegador, é importante declarar ao controller qual é a view que desejamos enviar. Esse processo é conhecido como renderização da view.
                  </p>
                  <p>
                     Agora que repassamos um pouco esses conceitos, vamos então aprender como um controller pode renderizar uma determinada view.
                  </p>
                  <video src="./Assets/Primeira View.mp4"></video>
                  <iframe src="./Assets/EJS - Renderizando Views.html" frameborder="0"></iframe>

                  <iframe src="./Assets/Minha primeira View com EJS.html" frameborder="0"></iframe>

                  <exercicio>
                     <h2>Exercício </h2>
                     <p>Para este exercício pedimos que complete o controlador do usuário fazendo com que ao invocar o loginUser o mesmo renderize com EJS a view login.</p>
                     <co-de>
                        let userController = {
                           loginUser: function (req,res){
                               res.render('login');
                           }
                       }
                     </co-de>
                  </exercicio>
               </display>
            </primeira-view>
            
            <tags-em-ejs>
               <h4>Tags em EJS</h4>
               <display>
                  <h1>Tags em EJS</h1>
                  <p>
                     Bom. Se chegamos até aqui, já sabemos o que é EJS, como instalá-lo em nosso projeto e como se dá o processo de renderização das vistas. Mas se o EJS parece ser a mesma coisa que o HTML, por que decidimos usar EJS então?
                  </p>
                  <p>
                     É chegada a horal de descobrir o incrível potencial que o EJS tem e o porquê, seguramente, de agora em diante, não irá querer voltar ao HTML básico e tradicional. No vídeo a seguir, veremos as tags próprias de EJS.
                  </p>
                  <p>
                     Estas tags são um conjunto de funcionalidades que nos vão permitir fazer coisas como uma iteração de um array dentro de um bloco de código HTML. Surpreendente, não?
                  </p>
                  <p>
                     Não vamos perder mais tempo, vamos ver como podemos, então, alcançar estes magníficos resultados.
                  </p>
                  <video src="./Assets/Tags em EJS.mp4"></video>
                  <iframe src="./Assets/Tags do EJS.html" frameborder="0"></iframe>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>Questionário: Tags Template Engine</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">O que permite a tag &lt;% ?</p>
                        </header>
                        <choices>
                           <label choice="asf">
                              <input type="radio">
                              <t>Agregar código e funcionalidades de JS no código HTML.</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Agregar código e funcionalidades de HTML no código JS</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="2">
                              Em um arquivo .ejs. Onde devo adicionar a tag &lt;% e %&gt; para que o for seja executado corretamente:

                              for (var i=0; i &lt;  umArray.length; i++) {
                              
                                        &lt;p&gt; item i &lt;/p&gt;
                              
                              }
                           </p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>Não preciso colocar a tag!</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Adicionaria a tag no começo do for e depois de termina-lo</t>
                           </label>
                           <label choice="faf">
                              <input type="radio">
                              <t>Adicionaria a tag para cada linha de código JS.</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="3">Qual a função da tag &lt;%= ?</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>É igual a tag &lt;% porém escrita de outra foram</t>
                           </label>
                           <label choice="asfa">
                              <input type="radio">
                              <t>Permite imprimir um valor dinâmico</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Permite utilizar o código HTML de outro arquivo</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                  </quiz>
               </display>
            </tags-em-ejs>
            
            <parametros-compartilhados>
               <h4>Parâmetros Compartilhados</h4>
               <display>
                  <h1>Parâmetros Compartilhados</h1>
                  <p>
                     Uma das melhores funcionalidades de uma view, é que temos a possibilidade de consumir informações fornecidas diretamente pelo controlador.
                  </p>
                  <p>
                     A esta funcionalidade damos o nome de parâmetros compartilhados. Basicamente, a partir do controlador, podemos compartilhar com a view qualquer tipo de dado existente no JavaScript. Objetos, arrays e funções. Sim, você leu bem: até funções podem ser compartilhadas do controlador para a view.
                  </p>
                  <p>
                     Vejamos, então, qual é o processo que temos que seguir para alcançar este tipo de resultado tão genial!
                  </p>
                  <video src="./Assets/Parâmetros compartilhados.mp4"></video>
                  <iframe src="./Assets/Parâmetros compartilhados.html" frameborder="0"></iframe>

                  <exercicio>
                     <h2>Exercício</h2>
                     <p>
                        Analisando o HTML  abaixo, escreva o código necessário no controller para que o mesmo possa enviar ao template engine as variáveis necessárias para poder executar o código.
                        <br>
                        Ah, o nome da nossa view é checkout.
                        <br>
                        Código HTML:
                     </p>
                     <code>
                        &lt;% for(let i =0; i &lt; itens.length; i++) {
                           &lt;li&gt;
                              &lt;%= itens[i] %&gt;
                           &lt;/li&gt;
                        &lt;% } %&gt;
                     </code>
                     <co-de>
                        let produtos = ['Sorvete 250g', 'Bolacha de Chocolate', 'Maçã 500g'];
                        let carrinhoController = {
                           checkout: function (req,res){
                              res.render( "checkout", {itens: produtos} );
                           }
                        }
                     </co-de>
                  </exercicio>
               </display>
            </parametros-compartilhados>
            
            <partial-files>
               <h4>Partial files</h4>
               <display>
                  <h1>Partial files</h1>
                  <p>
                     Quando desenvolvemos um site, é bastante comum existirem certos elementos visuais que costumam se repetir. Por exemplo, uma barra de navegação ou o rodapé da página são de uso comum e quase sempre são o mesmo em todas as views. Será que o EJS poderia nos dar uma ajudinha com isso?
                  </p>
                  <p>
                     A resposta para essa pergunta é sim. O EJS nos dá uma maneira de modularizar nossa estrutura HTML e gerar blocos de código repetidos, o quais podem ser facilmente integrados no resto das views.
                  </p>
                  <p>
                     Isso vai simplificar muitíssimo o trabalho de desenvolvimento e programação do nosso projeto web.
                  </p>
                  <p>Então, vamos ver como podemos alcançar esse objetivo.</p>
                  <video src="./Assets/Partial files.mp4"></video>
                  <iframe src="./Assets/Partial files.html" frameborder="0"></iframe>

                  <quiz>
                     <header>
                        <h2>Quiz</h2>
                        <question>
                           <h4>Questionário: Custom Template</h4>
                        </question>
                     </header>
                     <home>
                        <header>
                           <p n="1">Por questões de boas práticas, onde colocamos nossas views fragmentadas?</p>
                        </header>
                        <choices>
                           <label choice="">
                              <input type="radio">
                              <t>Na pasta fragment</t>
                           </label>
                           <label choice="dfsd">
                              <input type="radio">
                              <t>Na pasta partials</t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Na pasta view</t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                     <home>
                        <header>
                           <p n="2">Estando dentro do arquivo checkout.ejs, como posso adicionar a partial que representa o cabeçalho  que está no arquivo head.ejs?</p>
                        </header>
                        <choices>
                           <label choice="asfa">
                              <input type="radio">
                              <t>
                                 Acima de todo o arquivo insira o código &lt;%- include('./partials/head')%&gt;
                              </t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>
                                 Acima de todo o arquivo insira o código
                                 &lt;%- include('./partials/head')%&gt;
                              </t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Abaixo de todo o arquivo insira o código
                                 &lt;%- include('./partials/head')%&gt;
                              </t>
                           </label>
                           <label choice="">
                              <input type="radio">
                              <t>Abaixo de todo o arquivo insira o código
                                 &lt;%- include('./partials/head')%&gt;
                              </t>
                           </label>
                        </choices>
                        <res>
                           <p></p>
                        </res>
                     </home>
                  </quiz>
               </display>
            </partial-files>
            
            <storytelling>
               <h4>Storytelling</h4>
               <display>
                  <h1>Você recebeu uma mensagem da Camila</h1>
                  <h3>De: Camila</h3>
                  <p>
                     Vou direto ao ponto, porque é extenso, e a Ana vai explodir minha cabeça com os deadlines.
                  </p>
                  <p>
                     MVC não é: ”mas vai colar”, é um design pattern que significa Model, View, Controller, é largamente implementado e tem muita aceitação no ambiente de desenvolvimento.
                  </p>
                  <p>
                     No MVC, o M refere-se à model, que é a parte do programa que tem acesso à informação armazenada no banco de dados. Pode-se dizer que é o “armazém” no qual a Wikipedia tem guardada toda a sua informação.
                  </p>
                  <p>
                     O V refere-se à view, que é a parte visual do sistema na qual o usuário interage, é como a caixa de texto onde você escreve aquilo que quer pesquisar na Wikipedia
                  </p>
                  <p>
                     O C refere-se à controller, que é a ponte entre uma view e um model.
                  </p>
                  <p>
                     É quem requer ao model parte de sua informação e repassa essa informação à view. É como um robozinho, que sabe o que você está procurando, pede o que procura a alguém (model) e entrega o que conseguiu a outra alguém (view), para que você possa ver.
                  </p>
                  <hr>
                  <h2>Vistas dinâmicas em EJS</h2>
                  <p>
                     Uma view é a parte visual da nossa aplicação, em outras palavras, é o HTML e o CSS do nosso sistema. Recorde-se: EJS significa Embedded JavaScript. É um template engine que torna o HTML realmente dinâmico.
                  </p>
                  <p>
                     Tenha em mente que qualquer coisa que faça em EJS tem que ser previamente interpretada pelo servidor para que possa ser enviada ao navegador em formato plain HTML.
                  </p>
                  <p>
                     Com EJS você pode usar porções de JavaScript entre blocos de HTML, para gerar um conteúdo muito mais dinâmico e funcional, sem ter que repetir mil vezes o mesmo HTML plano.
                  </p>
                  <p>
                     EJS é como um HTML com super poderes.
                  </p>
                  <p>Vou tomar um café, você vem?</p>
               </display>
            </storytelling>
            
            <ao-vivo>
               <h4>Para a aula ao vivo</h4>
               <display>
                  <h1>Para a aula ao vivo</h1>
                  <p>Tudo bem, chegamos ao final desta grande aula.</p>
                  <p>
                     Para verificar os conhecimentos adquiridos de forma pessoal, podemos tentar resolver as seguintes questões:
                  </p>
                  <ol>
                     <li>
                        <p>O que são template engines?</p>
                     </li>
                     <li>
                        <p>Para que usamos template engines?</p>
                     </li>
                     <li>
                        <p>Por que usamos o EJS como mecanismo de template?</p>
                     </li>
                     <li>
                        <p>O que significa o conceito de "renderização de views"?</p>
                     </li>
                     <li>
                        <p>O que as tags próprias do EJS nos ajudam a resolver?</p>
                     </li>
                     <li>
                        <p>Como podemos passar informações do controller para a view?</p>
                     </li>
                     <li>
                        <p>Como a modularização da view nos ajuda?</p>
                     </li>
                  </ol>
                  <p>
                     Se pudermos responder a essas perguntas de forma simples e contundente, teremos todos os conceitos prontos para nos encontrarmos na aula ao vivo. Se, ao contrário, sentimos que estamos hesitantes em algumas perguntas, o ideal seria rever os tópicos do vídeo novamente. Assim, poderemos encontrar a resposta correta para essas pequenas dúvidas.
                  </p>
                  <p>Nos vemos na aula!</p>
               </display>
            </ao-vivo>
            
            <views-com-ejs-ao-vivo>
               <h4>Views com EJS [ao Vivo]</h4>
               <display>
                  <h1>Views com EJS [ao Vivo]</h1>
                  <p>Chegou a hora de colocar à prova os conhecimentos que adquirimos na aula virtual e, para isso, vamos brincar um pouco com o EJS nesta aula ao vivo.</p>
                  <p>Nossos principais objetivos desta aula são:</p>
                  <ul>
                     <li>
                        <p>Esclarecer quaisquer dúvidas sobre o que são os templates engines.</p>
                     </li>
                     <li>
                        <p>Compreender completamente o que é uma view em si.</p>
                     </li>
                     <li>
                        <p>Processar o conceito de "renderização de views".</p>
                     </li>
                     <li>
                        <p>Migrar um pequeno projeto de HTML para EJS.</p>
                     </li>
                     <li>
                        <p>Aprenda a enviar dados do controller para a view.</p>
                     </li>
                     <li>
                        <p>Modularizar nossos arquivos EJS.</p>
                     </li>
                  </ul>
                  <p>Sem mais delongas, vamos ao arquivo de exercícios e ver o desafio que ele representa para nós neste momento.</p>
                  <iframe src="./Assets/Views com EJS.html" frameborder="0"></iframe>
                  <hr>
                  <iframe src="./Assets/Vistas dinamicas com EJS - Prática integradora.pdf" frameborder="0"></iframe>

                  <h2>Arquivos para a prática MVC - zip</h2>
                  <p><a href="./Assets/arquivos_para_a_pratica.zip" download="">arquivos_para_a_pratica.zip</a></p>
                  <h2>Prática resolvida EJS - zip</h2>
                  <p><a href="./Assets/pimenta-sal.zip" download="">pimenta-sal.zip</a></p>
               </display>
            </views-com-ejs-ao-vivo>
            
         </Views-com-ejs>

         <crud-upload-de-arquivos-multer>
            <small>CRUD-upload de arquivos/multer</small>
            <intro>
               <h4>O que vamos ver nessa aula?</h4>
               <display>
                  <h1>O que vamos ver nessa aula?</h1>
                  <p>
                     Até agora, estávamos salvando nada mais que informação de texto em nosso servidor, por meio dos diferentes métodos de HTTP, como GET, POST, PUT e DELETE.
                  </p>
                  <p>
                     Mas, como podemos fazer upload de arquivos para serem armazenados no servidor?
                  </p>
                  <p>
                     Pensemos por um momento em uma loja virtual, onde qualquer pessoa usuária do sistema possa publicar produtos. Seria bastante entediante se estas publicações não tivessem uma imagem sequer para mostrar, não?
                  </p>
                  <p>
                     Por isso, ao longo dessa aula, seremos apresentados ao mágico mundo do upload de arquivos no servidor. Um processo que não é tão complexo, mas que também não é tão trivial.
                  </p>
                  <p>
                     Ao finalizar esta aula, seremos capazes de:
                  </p>
                  <ul>
                     <li>
                        <p>
                           Entender o passo a passo obrigatório para o processamento de arquivos do lado do servidor
                        </p>
                     </li>
                     <li>
                        <p>
                           Manipular a biblioteca mais utilizada para esta funcionalidade, chamada Multer
                        </p>
                     </li>
                     <li>
                        <p>
                           Implementar o lugar dentro do servidor onde queremos que sejam armazenados os arquivos
                        </p>
                     </li>
                     <li>
                        <p>
                           Criar uma nomenclatura correta de arquivos para que os mesmos sejam consistentes ao longo de toda a aplicação
                        </p>
                     </li>
                  </ul>
                  <p>Assim, vamos com tudo mergulhar nesse conteúdo!</p>
               </display>
            </intro>
            
            <multer-apresentacao-e-installation>
               <h4>Apresentando o Multer</h4>
               <display>
                  <h1>Apresentando o Multer</h1>
                  <p>
                     Nenhum sistema que se preze pode ser considerado 100% pronto se não implementar um processo que permita o envio de arquivos para o servidor. E é justamente aqui onde a biblioteca Multer se encaixa com perfeição.
                  </p>
                  <p>
                     Multer é um pacote do npm para processar arquivos do lado do servidor. Este pacote é usado em geral como um middleware e não só nos permite enviar arquivos para servidor, como também nos permite escolher um que local do servidor queremos que sejam armazenados estes arquivos, além do nome que cada um deles terá.
                  </p>
                  <p>
                     Esta biblioteca tem uma implementação simples, mas exige bastante atenção para cada um dos passos de sua configuração porque, se não o fizermos direito, seguramente não teremos o resultado esperado.
                  </p>
                  <p>
                     Então, sem mais delongas, vamos ver com detalhes como podemos implementar o Multer dentro dos nossos projetos com Express.
                  </p>
                  <video src="./Assets/Multer - introdução e instalação.mp4"></video>
                  <hr>
                  <iframe src="https://view.genial.ly/62139804293ca70011d84aac" frameborder="0"></iframe>
               </display>
            </multer-apresentacao-e-installation>
            
            <multer-subindo-arquivos>
               <h4>Multer: subindo arquivos</h4>
               <display>
                  <h1>Multer: subindo arquivos</h1>
                  <p>
                     Vimos anteriormente o processo necessário para configurar o pacote Multer em nossos projetos Express. Agora vamos nos aprofundar um pouco mais neste processo.
                  </p>
                  <p>
                     Chegou a hora de conhecer e entender como ocorre o processo de finalmente poder armazenar arquivos em nosso servidor.
                  </p>
                  <p>
                     Tarefa relativamente simples, mas que exige (como tudo no campo do desenvolvimento) de muitos neurônios a atenção para evitar passos em falso.
                  </p>
                  <p>Então, vamos ver como podemos realizar esse processo maravilhoso.</p>
                  <video src="./Assets/Multer subindo arquivos.mp4"></video>
                  <iframe src="./Assets/Subindo arquivos com Multer.html" frameborder="0"></iframe>

                  <exercicios>
                     <exercicio>
                        <h3>Exercício 1</h3>
                        <h2>Preparando formulários para subir arquivos</h2>
                        <p>
                           Ao carregar arquivos através do formulário, não apenas precisamos configurar nosso código no Node, mas também devemos adicionar uma configuração extra na tag form.
                           <br>
                           <br>
                           Dado o seguinte formulário, adicione o atributo enctype com o valor correspondente para permitir o envio de arquivos.
                        </p>
                        <co-de>
                           &lt;html&gt;
                              &lt;head&gt;
                                &lt;title&gt;Upload de Imagens&lt;/title&gt;
                              &lt;/head&gt;
                              &lt;body&gt;
                                &lt;form action="upload" method="POST" enctype="multipart/form-data"&gt;
                                &lt;input type="file" name="files"&gt;
                                &lt;/form&gt;
                              &lt;/body&gt;
                            &lt;/html&gt;
                        </co-de>
                     </exercicio>
                     
                     <exercicio>
                        <h3>Exercício 2</h3>
                        <h2>Usando Multer para subir arquivos</h2>
                        <p>
                           No Node, para fazer upload de arquivos, podemos usar ferramentas como multer. É simplesmente necessário adicioná-lo ao arquivo de rota onde nossa rota ou rotas são responsáveis ​​pelo upload de arquivos (imagens, documentos, etc.).
                           <br></br>
                           Neste exemplo, adicionaremos multer ao arquivo de routes user.js para permitir que os usuários anexem uma imagem durante o registro.
                           <br></br>Para isso, será necessário requisitar o módulo multer, criar o armazenamento, inicializar a variável de upload e adicionar a rota que já temos definidas a expressão upload.any() como segundo parâmetro.
                           <br></br>
                           Para ver a configuração que a multer precisa para funcionar, consulte a documentação oficial:
                           <br></br>
                           <a href="https://www.npmjs.com/package/multer#diskstorage">https://www.npmjs.com/package/multer#diskstorage.</a>
                        </p>
                        <co-de>
                           const express = require('express');
                           const router = express.Router();
                           const multer = require( "multer" );
                           const path = require( "path" );
                           
                           const storage = multer.diskStorage({
                             destination: function (req, file, cb) {
                               cb(null, '/tmp/my-uploads')
                             },
                             filename: function (req, file, cb) {
                               const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9)
                               cb(null, file.fieldname + '-' + uniqueSuffix)
                             }
                           })
                           
                           const upload = multer({ storage: storage })
                           
                           router.post('/register', upload.any(), usersController.save);
                        </co-de>
                     </exercicio>
                     
                  </exercicios>
               </display>
            </multer-subindo-arquivos>
            
            <multer-validacao>
               <h4>Multer: validação</h4>
               <display>
                  <h1>Multer: validação</h1>
                  <p>
                     Vamos pensar por um segundo sobre nosso processo de registro de usuário.
                  </p>
                  <p>
                     Com certeza já percebemos que cada pessoa que se cadastrar deve preencher certas informações como nome, e-mail e outras. E, possivelmente, dentro desta informação decidimos dar a possibilidade da pessoa carregar uma imagem de perfil para o servidor.
                  </p>
                  <p>
                     Agora, o que aconteceria se nosso sistema estivesse esperando para receber uma imagem de cada usuário, mas outra pessoa carregasse um arquivo Excel?

                  </p>
                  <p>
                     Certamente nosso sistema não pareceria muito bom, certo?
                  </p>
                  <p>
                     Por isso o processo de validação é algo da maior importância e nada trivial, pois nos permitirá evitar este tipo de erro e garantir que a informação que se armazena no nosso servidor seja a que realmente queremos e esperamos.

                  </p>
                  <p>Vamos ver como o Multer nos permite validar os arquivos que queremos armazenar no lado do servidor.</p>
                  <video src="./Assets/Multer validação básica.mp4"></video>
                  <iframe src="./Assets/Validando arquivos com o Multer.html" frameborder="0"></iframe>

                  <exercicio>
                     <h4>Exercício 1</h4>
                     <h2>Validação</h2>
                     <p>Precisamos enviar um formulário, mas antes precisamos verificar se todos os inputs foram devidamente preenchidos!</p>
                     <small>HTML </small>
                     <co-de>
                        &lt;html&gt;
                           &lt;form id="formulario"&gt;
                               &lt;div class="input-group"&gt;
                                   &lt;label for="name"&gt;*Nome&lt;/label&gt;
                                   &lt;input type="text" id="name"/&gt;
                               &lt;/div&gt;
                               &lt;div class="input-group"&gt;
                                   &lt;label for="email"&gt;*Email&lt;/label&gt;
                                   &lt;input type="email" id="email"/&gt;
                               &lt;/div&gt;
                               &lt;div class="input-group"&gt;
                                   &lt;label for="password"&gt;*Senha&lt;/label&gt;
                                   &lt;input type="password" id="password"/&gt;
                               &lt;/div&gt;
                               &lt;button&gt;Enviar&lt;/button&gt;
                           &lt;/form&gt;
                           &lt;ul id="errors"&gt;&lt;/ul&gt;
                       &lt;/html&gt;
                     </co-de>
                     <small>script</small>
                     <co-de>
                        window.addEventListener('load', () => {
                           const formulario = document.getElementById('formulario')
                           const msgSucesso = document.getElementById('name')
                           const emailInput = document.getElementById('email')
                           const senhaInput = document.getElementById('password')
                           const errosContainer = document.getElementById('errors')
                       
                           const erros = []
                       
                           formulario.addEventListener( 'submit', event => {
                               event.preventDefault();
                       
                               if( msgSucesso != '' || emailInput != '' || senhaInput != '' ){}
                           } )
                       })
                     </co-de>
                  </exercicio>
               </display>
            </multer-validacao>
            
            <ao-vivo>
               <h4>Para a aula ao vivo</h4>
               <display>
                  <h1>Para a aula ao vivo</h1>
                  <p>
                     No live meeting está por vir, trabalharemos e implementaremos o pacote Multer, com o objetivo de nossos sistemas passarem a ter a possibilidade de processamento de arquivos.
                  </p>
                  <p>
                     Por isso, antes da aula e, para ter certeza de que temos todas as informações prontas, vamos dedicar alguns minutos para pensar nas seguintes questões:
                  </p>
                  <ul>
                     <li>
                        <p>Qual é a configuração básica, mas necessária para que o Multer funcione conforme o esperado?</p>
                     </li>
                     <li>
                        <p>Multer: é um middleware de aplicativo ou é um middleware de rota?</p>
                     </li>
                     <li>
                        <p>Quais são os atributos necessários no formulário HTML para que o Express possa entender que você deseja enviar arquivos para o servidor?</p>
                     </li>
                     <li>
                        <p>Como podemos gerar o nome do arquivo que se deseja salvar, de modo que esse nome seja único e não ambíguo? Caso o que queiramos enviar seja uma imagem ou um arquivo Excel, o Multer tem a possibilidade de validá-los?</p>
                     </li>
                  </ul>
                  <p>
                     Se pudéssemos encontrar as respostas a essas perguntas por conta própria, estaríamos mais do que bem. "Keep calm and" pelo encontro ao vivo.
                  </p>
                  <p>
                     Se, por outro lado, não conseguimos chegar à solução de algumas, ou da maioria, das respostas para essas questões, o ideal seria revisar os vídeos novamente e prestar muita atenção aos processos ali citados, pois assim estaremos capazes de ter tudo pronto para o nosso próximo encontro.
                  </p>
                  <p>Até a próxima aula!</p>
               </display>
            </ao-vivo>
            
            <crud-2>
               <h4>CRUD II</h4>
               <display>
                  <h1>CRUD II</h1>
                  <iframe src="./Assets/Multer.html" frameborder="0"></iframe>
               </display>
            </crud-2>
            
            <ponto-de-partida>
               <h4>Ponto de partida</h4>
               <display>
                  <h1>Ponto de partida</h1>
                  <p>Nesta aula buscaremos atingir os seguintes objetivos:</p>
                  <ul>
                     <li>
                        <p>Revisar as diferentes solicitações que podemos fazer ao servidor.</p>
                     </li>
                     <li>
                        <p>Conhecer mais sobre as diferenças entre os métodos HTTP para poder realizar um CRUD.</p>
                     </li>
                     <li>
                        <p>Carregar arquivo de exercício usando multer.</p>
                     </li>
                     <li>
                        <p>Revisar o path e fs.</p>
                     </li>
                  </ul>
                  <p>Para isso, deixamos para você o seguinte exercício.</p>
               </display>
            </ponto-de-partida>
            
            <crud-2-ao-vivo>
               <h4>CRUD II [ao Vivo]</h4>
               <display>
                  <h1>CRUD II [ao Vivo]</h1>
                  <iframe src="./Assets/CRUD episódio II - Prática integradora.pdf" frameborder="0"></iframe>
               </display>
            </crud-2-ao-vivo>
            
         </crud-upload-de-arquivos-multer>

         <sprint-3-pi></sprint-3-pi>

         <middlewares>
            <small>Middlewares</small>

            <intro>
               <h4>O que vamos ver nesta aula?</h4>
               <display>
                  <h1>O que vamos ver nesta aula?</h1>
                  <p>
                     Nesta aula, vamos entrar em detalhes dos conceitos chaves do que exatamente venha a ser um middleware, porque, alerta de spoiler, muitas coisas dentro do ambiente Express são middlewares. Então, o que vamos aprender agora é:
                  </p>
                  <ul>
                     <li>
                        <p>O que é exatamente um middleware</p>
                     </li>
                     <li>
                        <p>Como podemos aplicar um middleware e suas diversas formas de aplicação</p>
                     </li>
                     <li>
                        <p>A diferença entre um middleware de aplicação global e um middleware de rota</p>
                     </li>
                  </ul>
                  <p>
                     Adicionalmente, vamos trabalhar com um pacote do npm chamado express-validator, que nos permite validar os dados que nossa aplicação recebe do front-end, garantindo que nosso banco de dados possa salvar a informação de maneira limpa e consistente.
                  </p>
               </display>
            </intro>
            
            <teoria>
               <h4>Middlewares: teoria</h4>
               <display>
                  <h1>Middlewares: teoria</h1>
                  <p>
                     Como realmente o Express funciona por dentro?
                  </p>
                  <p>A seguir, vamos ver o que acontece por debaixo dos "panos", para que finalmente possamos visualizar que toda essa "magia" que se cria com as rotas, models e controllers. Não são tão mágicas assim, na verdade têm algumas boas doses de lógica e outras de processamento imperativo.</p>
                  <p>
                     Um middleware, em palavras simples, não é nada mais que um intermediário de processamento lógico, entre o request e o response. Uma função no “meio”.
                  </p>
                  <video src="./Assets/Middlewares - teoria.mp4"></video>
                  <hr>
                  <iframe src="./Assets/Middlewares.html" frameborder="0"></iframe>
                  <hr>
                  <h2>Características dos middlewares</h2>
                  <ol>
                     <li>
                        <p>O Express trata o request e o response como objetos. Recebe um pedido, o processa e devolve um objeto como resposta.</p>
                     </li>
                     <li>
                        <p>Todo pedido exige uma série de passos para ser processado. O Express divide essas responsabilidades em funções denominadas middlewares.</p>
                     </li>
                     <li>
                        <p>Os middlewares são funções executadas entre a execução do pedido do cliente e a resposta ao mesmo.</p>
                     </li>
                     <li>
                        <p>As rotas que precisam de middlewares -além do request e do response- devem receber um terceiro parâmetro: a função next.</p>
                     </li>
                     <li>
                        <p>next permite a execução em cadeia de todas as funções necessárias que devem ser executadas antes de enviar a resposta ao cliente.</p>
                     </li>
                     <li>
                        <p>Com os middlewares, podemos isolar código que nos permita resolver um cenário particular e implementá-lo onde seja necessário, evitando assim repetir código.</p>
                     </li>
                     <li>
                        <p>Estas funções adicionam um nível de segurança. Se a função que definimos como middleware não retorna o esperado, ela interrompe a execução em cadeia e devolverá a resposta definida para esses casos.</p>
                     </li>
                  </ol>
                  <hr>
                  <h2>Departamentos Digital House</h2>
                  <h4>Departamento de desenvolvimento profissional e graduados</h4>
                  <p>
                     Nossa missão é melhorar o desenvolvimento profissional de nossos alunos, acompanhando-os e orientando-os na realização de seus objetivos profissionais. Na metade do curso, lhe daremos acesso ao curso de desenvolvimento profissional para que você possa acessar conteúdos relevantes que lhe permitirão criar seu perfil digital profissional, ganhar visibilidade em redes profissionais e trabalhar em suas habilidades profissionais para melhorar sua empregabilidade. Além disso, você poderá ter acesso a sessões de coaching com profissionais da equipe.
                  </p>
                  <h4>Departamento de pedagogia</h4>
                  <p>
                     Nossa equipe docente é constantemente acompanhada pela equipe pedagógica. É uma equipe interdisciplinar de profissionais responsáveis por elaborar, juntamente com a equipe acadêmica, as melhores propostas de ensino para alcançar caminhos de aprendizagem bem sucedidos.
                  </p>
                  <h4>O Departamento de alunos</h4>
                  <p>
                     No departamento estudantil, nossa missão é acompanhá-lo durante todo o curso para que você tenha a melhor experiência na Digital House. Estamos disponíveis para responder às suas perguntas, acompanharmos seu atendimento, entregas individuais, trabalho em grupo e desempenho em geral.
                  </p>
                  <p>
                     A partir deste momento, estamos aqui para acompanhá-lo em sua jornada para torná-la uma experiência de aprendizado inesquecível!
                  </p>
                  <sub>
                     Se você tiver alguma dúvida, não hesite em entrar em contato 
                     <a href="malito:alumnos@digitalhouse.com">malito:alumnos@digitalhouse.com</a>
                  </sub>
                  <p>Vamos começar.</p>
                  <hr>

               </display>
            </teoria>
            
            <aplicacao-global>
               <h4>Middlewares: aplicação global</h4>
               <display>
                  <h1>Middlewares: aplicação global</h1>
                  <p>
                     Como mencionamos nos blocos anteriores, um middleware é um bloco de código que vai ser executado no "meio" de uma determinada solicitação e, em algumas ocasiões, certamente precisaremos que esse código seja executado em toda a aplicação. É aí que os middlewares de aplicativos globais assumem um papel especial. Eles SEMPRE estarão presentes e SEMPRE rodarão, não importa para onde o visitante vá em nosso aplicativo.
                  </p>
                  <p>
                     Neste ponto, podemos ter implementado a pasta de recursos estáticos, certo? Bem, isso sem dúvida é um middleware global. Nesse caso particular, nosso interesse é disponibilizar os arquivos ali presentes para que qualquer view possa utilizá-los.
                  </p>
                  <p>
                     Portanto, vamos entrar neste conceito específico de middleware de aplicativo global.
                  </p>
                  <video src="./Assets/Middlewares aplicação global.mp4"></video>
                  <hr>
                  <iframe src="./Assets/Middlewares em nível global.html" frameborder="0"></iframe>
                  <hr>

                  <exercicios>
                     
                     <exercicio>
                        <h4>Exercício 1</h4>
                        <h2>Adicionando o middleware express.json()</h2>
                        <p>
                           Nós já temos a nossa rota de registro. O que precisamos fazer agora é adicionar uma validação para que o campo de e-mail seja do tipo email e a senha tenha, pelo menos, 6 caracteres.
                           <br></br>
                           Para conseguir isso, vamos requerer o módulo de express-validator e, usando o destructuring, vamos inicializar três constantes: check, validationResult e body.
                           <br>
                           (PS: Por limitações, é aconselhado que dê um alias para o método check, mudando o nome para ‘checar’).
                           <br></br>
                           Em nossa rota, adicionaremos como segundo parâmetro um array. Ele terá apenas duas posições, uma para validar a entrada de dados no input "email" e outra para validar a entrada em "password".
                           <br></br>
                           Em cada posição do array, usaremos a função check, passando como parâmetro o input a ser validado e concatenamos à execução desta função uma segunda função, que será a regra que queremos que nosso input atenda, por exemplo, isEmail.
                        </p>
                        <co-de>
                           const express = require('express');

                           const router = express.Router();
                           
                           const UsuarioController = require('../controllers/UsuarioController');
                           
                           const {check: checar, validationResult, body} = require( "express-validator" );
                           
                           router.post('/cadastro', [checar('password').isLength({min: 6}), checar('email').isEmail()],  UsuarioController.registro);
                        </co-de>
                     </exercicio>
                     
                     <exercicio>
                        <h4>Exercício 2</h4>
                        <h2>Site em manutenção</h2>
                        <p>
                           Aproveitando a capacidade dos middleware, vamos criar um código que podemos informar se o site esta em manutenção e mostra uma view personalizada informando o usuário, independente da rota que ele esteja acessando.
                           <br></br>
                           Neste exemplo temos criada uma variável chamada "emManutencao" configurada por padrão com o valor false.
                           <br></br>
                           Nós vamos ter que, usando o método use de app, criar uma função que avalia o valor da variável "emManutencao". Se a variável tiver o valor false devemos executar a função next do middleware para que o fluxo da aplicação continue normalmente. Mas se a variável tiver o valor true vamos devolver a view 'em-manutencao', usando o objeto response para isso.
                        </p>
                        <co-de>
                           const express = require('express');
                           const app = express();
                           let emManutencao = false;
                           
                           app.use( ( req, res, next ) => {
                               res.render( "em-manutencao" );
                               next();
                           } );
                        </co-de>
                     </exercicio>
                     
                  </exercicios>
               </display>
            </aplicacao-global>
            
            <aplicacao-por-rota>
               <h4>Middlewares: aplicação ao nível de rota</h4>
               <display>
                  <h1>Middlewares: aplicação ao nível de rota</h1>
                  <p>
                     Anteriormente, vimos que o Express nos permite aplicar middlewares para TODA nossa aplicação, mas o que acontece com aquele código que desejamos ser executado somente para uma das rotas ou para um grupo de rotas específicas?
                  </p>
                  <p>
                     É justamente sobre isso que trata o conceito de middleware no nível de rota, com a particularidade de podermos especificar em que rota desejamos implementar um determinado middleware.
                  </p>
                  <sub>
                     Lembre-se: os middlewares no nível de rota são aqueles que são executados única e
exclusivamente ao entrar naquelas rotas que definimos previamente.
                  </sub>
                  <video src="./Assets/Middlewares aplicação por rota.mp4"></video>
                  <hr>
                  <iframe src="./Assets/Middlewares em nível de rotas.html" frameborder="0"></iframe>

                  <exercicios>
                     <exercicio>
                        <h4>Exercício 1</h4>
                        <h2>Adicionando middleware à rota "upload-file"</h2>
                        <p>
                           Ao contrário do middleware de aplicação que roda para todas as rotas, os middlewares de rotas permite que você aplique o middleware em uma ou mais rotas selecionadas.
                           <br></br>
                           Um exemplo disso é o middleware multer que é adicionado apenas às rotas responsáveis pelo upload de arquivos. (Lembre-se que multer é um pacote node que permite o upload de arquivos para o servidor).
                           <br></br>
                           Para este exemplo já temos a configuração do multer pronto, mas precisamos adicionar o middleware no caminho "upload-file".
                           <br></br>
                           Para isso, teremos que passar como segundo parâmetro o arquivo de rota de upload do middleware upload.any().
                        </p>
                        <co-de>
                           const express = require('express');
                           const router = express.Router();
                           const multer = require('multer');
                           
                           const storage = multer.diskStorage({
                             destination: function (req, file, cb) {
                               cb(null, '/tmp/my-uploads')
                             },
                             filename: function (req, file, cb) {
                               cb(null, file.fieldname + '-' + Date.now())
                             }
                           });
                            
                           const upload = multer({ storage: storage });
                           
                           router.post('/upload-file', upload.any(), fileController.upload);
                        </co-de>
                     </exercicio>
                     
                     <exercicio>
                        <h4>Exercício 2</h4>
                        <h2>Contabilizando Acessos</h2>
                        <p>
                           Vamos imaginar que temos um controller chamado "estatisticasController" que tem um método "contarAcesso". Este método recebe um request e adiciona, em nossa base de dados, um novo acesso à url do request.
                           <br></br>
                           Gostaríamos de contar os acessos do nosso site, mas não de todas as urls. Por exemplo, não queremos contar as visitas à rotas acessadas por post e algumas rotas get, como login e painel de usuário.
                           <br></br>
                           Nosso objetivo será criar uma função chamada visitasMiddleware que recebe como parâmetros req, res e next. Dentro desta função vamos executar o método contarAcesso de estatisticasController, e vamos passar o objeto pedido como parâmetro para o método: estatisticasController.contarAcesso(req). No final da nossa função vamos executar o callback next().
                           <br></br>
                           Por fim, vamos adicionar nossa função "visitasMiddleware" como o segundo parâmetro da rota '/home' que já está definida no código.
                        </p>
                        <co-de>
                           const express = require('express'),
                           router = express.Router(),
                           homeController = require('../controllers/homeController'),
                           estatisticasController = require('../controllers/estatisticasController');
                       
                       function visitasMiddleware (req, res, next) {
                           estatisticasController.contarAcesso(req);
                           next();
                       }
                       
                       router.get('/home', visitasMiddleware, homeController.index);
                        </co-de>
                     </exercicio>
                     
                     <exercicio>
                        <h4>Exercício 3</h4>
                        <h2>Redirecionando para Página Inicial</h2>
                        <p>
                           Algumas rotas em nosso site foram descontinuadas e não temos mais conteúdo para exibir. Gostaríamos de garantir que quando um usuário tente entrar em qualquer uma dessas rotas, ele seja redirecionado para a página inicial.
                           <br></br>
                           Para isso vamos criar uma função chamada "redirecionar", que vai ser usada como middleware e deve receber três parâmetros: req, res e next.
                           <br></br>
                           Dentro da nossa função vamos chamar o método redirect do objeto response e vamos redirecioná-lo para a url '/'. Para este caso em particular, não é necessário chamarmos o callback next, já que a idéia deste redirecionamento é cortar a execução dos possíveis middlewares subsequentes.
                           <br></br>
                           Finalmente só temos que adicionar a função "redirecionar" como segundo parâmetro da rota '/rota-em-desuso'.
                        </p>
                        <co-de>
                           const express = require('express');
                           const router = express.Router();
                           const OldController = require('../controllers/OldController');
                           
                           function redirecionar( req, res, next ) {
                               res.redirect( "/" );
                           }
                           
                           router.get('/rota-em-desuso', redirecionar, OldController.index);
                        </co-de>
                     </exercicio>
                     
                  </exercicios>
               </display>
            </aplicacao-por-rota>
            
            <express-validator>
               <h4>Introdução ao Express Validator</h4>
               <display>
                  <h1>Introdução ao Express Validator</h1>
                  <p>
                     O que aconteceria se, em nosso banco de dados, no campo onde esperamos salvar um e-mail, um número de telefone fosse salvo? Certamente isso apresentaria sérios problemas de consistência em nossos dados e talvez o sistema começasse a apresentar algum outro problema.
                  </p>
                  <p>
                     É justamente esse tipo de inconveniente, e outros, que pacotes Node.js como o Express Validator, que nos ajudam a validar os dados, vêm solucionar.
                  </p>
                  <p>
                     Express Validator é um pacote Node.js que já vem preparado com uma série de regras e lógicas, o que nos permitirá validar o formato das informações que queremos armazenar no banco de dados de nossa aplicação.
                  </p>
                  <p>
                     Este pacote é usado como middleware e ainda nos fornece a lista de erros que ocorreram no envio das informações do front-end para o back-end.

                  </p>
                  <p>Mas não vamos perder mais tempo, vamos ver o que esse pacote pode fazer.</p>
                  <video src="./Assets/Express Validator - introdução.mp4"></video>
                  <hr>
                  <iframe src="./Assets/Express Validator - introdução.html" frameborder="0"></iframe>

                  <exercicio>
                     <h4>Exercício 1</h4>
                     <h2>Validando campos de cadastro</h2>
                     <p>
                        Nós já temos a nossa rota de registro. O que precisamos fazer agora é adicionar uma validação para que o campo de e-mail seja do tipo email e a senha tenha, pelo menos, 6 caracteres.
                        <br></br>
                        Para conseguir isso, vamos requerer o módulo de express-validator e, usando o destructuring, vamos inicializar três constantes: check, validationResult e body.
                        <br>
                        (PS: Por limitações, é aconselhado que dê um alias para o método check, mudando o nome para ‘checar’).
                        <br></br>
                        Em nossa rota, adicionaremos como segundo parâmetro um array. Ele terá apenas duas posições, uma para validar a entrada de dados no input "email" e outra para validar a entrada em "password".
                        <br></br>
                        Em cada posição do array, usaremos a função check, passando como parâmetro o input a ser validado e concatenamos à execução desta função uma segunda função, que será a regra que queremos que nosso input atenda, por exemplo, isEmail.
                     </p>
                     <co-de>
                        const express = require('express');

                        const router = express.Router();
                        
                        const UsuarioController = require('../controllers/UsuarioController');
                        
                        const { check: checar, validationResult, body } = require( "express-validator" );
                        
                        
                        router.post('/cadastro', [ checar( "email" ).isEmail(), checar( "password" ).isLength( { min: 6 } ) ],  UsuarioController.registro);
                     </co-de>
                  </exercicio>
               </display>
            </express-validator>
            
            <express-validator-avancado>
               <h4>Express Validator avançado</h4>
               <display>
                  <h1>Express Validator avançado</h1>
                  <p>Agora que sabemos o que é o Express Validator e tivemos nossa primeira abordagem com este pacote, é hora de ir mais longe e aproveitar ao máximo essa ótima ferramenta para nossos desenvolvimentos.</p>
                  <video src="./Assets/Express Validator avançado.mp4"></video>
                  <hr>
                  <iframe src="./Assets/Express Validator avançado.html" frameborder="0"></iframe>

                  <exercicio>
                     <h2>Exercício </h2>
                     <p>
                        Neste exercício, temos um controlador com um método de login. Devemos reformular este método, adicionando um IF (condição) para verificar se há erros de validação. No caso de haver erros, devemos redirecionar o usuário à tela de login com os erros encontrados. 
                        <br></br>
                        Para fazer isso, precisaremos criar uma constante chamada erros e vamos atribuí-la à execução da função de validationResult.
                        <br></br>
                        Então em um IF chamaremos o método isEmpty do objeto erros.
                        <br></br>
                        Caso o método retorne false (saberemos que não está vazio porque contém erros), devemos retornar a visualização de login com os erros.
                        <br></br>
                        Para retornar a visualização de login você deve usar o método render do objeto response. Lembre-se que para recuperar os erros você deve usar o método array do objeto erros.
                     </p>
                     <co-de>
                        const express = require('express');
                        const router = express.Router();
                        const { validationResult } = require('express-validator');
                        
                        const userController = {
                          login: (req, res) => {
                            const erros = validationResult(req);
                        
                            if( !erros.isEmpty() ) {
                              res.render( "login", { erros: erros.array() } );
                            }
                        
                            if (req.body.name == 'admin' && req.body.pass == 123) {
                               res.redirect('/dashboard');
                            }
                          }  
                        }
                     </co-de>
                  </exercicio>
               </display>
            </express-validator-avancado>
            
            <Validacao-completa-com-express-validator>
               <h4>Validação completa com express validator</h4>
               <display>
                  <h1>Validação completa com express validator</h1>
                  <p>
                     Como vimos, o processo de validação de dados não é algo supérfluo e banal, mas também não é uma ciência espacial.
                  </p>
                  <p>
                     Porém, para que todo esse processo fique o mais resolvido possível e para que cada uma de suas etapas seja compreendida, deixamos este capítulo de vídeo no qual faremos passo a passo, manualmente, todo o processo de validação de dados, do início ao fim.
                  </p>
                  <p>
                     Recomendamos replicar as etapas que estamos vendo no capítulo em um projeto de teste que temos para que, dessa forma, possamos assimilar muito melhor esses conceitos.
                  </p>
                  <iframe src="https://view.genial.ly/6049aa033b77f00d7e90e246" frameborder="0"></iframe>
                  <hr>
                  <video src="./Assets/Validação completa com express validator - Parte 1.mp4"></video>
                  <hr>
                  <video src="./Assets/Validação completa com express validator - Parte 2.mp4"></video>
                  <hr>
                  <iframe src="https://view.genial.ly/620280908770f00018be0a86" frameborder="0"></iframe>
               </display>
            </Validacao-completa-com-express-validator>
            
            <ao-vivo>
               <h4>Para a aula ao vivo</h4>
               <display>
                  <h1>Para a aula ao vivo</h1>
                  <p>
                     Ao longo desta aula trabalhamos os conceitos-chave de middlewares e também os implementamos no nível global e no nível da rota. Além disso, tomamos conhecimento do pacote express-validator e de como ele nos permite validar os dados que serão armazenados em nosso banco de dados.
                  </p>
                  <p>Com isto em mente, deixamos as seguintes perguntas como um auto-exame:</p>
                  <ul>
                     <li>
                        <p>
                           Entendendo que um middleware é uma função, além dos parâmetros que representam o request e o response, que outro parâmetro deve estar presente?
                        </p>
                     </li>
                     <li>
                        <p>
                           Para a pasta de recursos estáticos, onde as imagens e as folhas de estilo de visualização são armazenadas, deve ser utilizado um middleware global ou um middleware de rota?
                        </p>
                     </li>
                     <li>
                        <p>Qual é a vantagem de usar middlewares de rota?</p>
                     </li>
                     <li>
                        <p>Para usar o express-validator, ele tem que ser instalado ou vem por padrão com o Express?</p>
                     </li>
                     <li>
                        <p>
                           Quais são os dois principais lugares onde o express-validator deve ser usado para validar os dados da nossa aplicação?
                        </p>
                     </li>
                     <li>
                        <p>Como enviar os erros gerados na validação para que eles sejam exibidos na visualização?</p>
                     </li>
                     <li>
                        <p>Na view, os erros de validação estarão sempre presentes?</p>
                     </li>
                  </ul>
                  <p>
                     Se conseguirmos responder a todas as perguntas sem nenhum problema, estamos mais do que bem preparados para a aula sincrônica.
                  </p>
                  <p>
                     Se, por outro lado, tivermos dúvidas sobre qualquer uma das perguntas, recomendamos que você olhe novamente o material para esclarecer qualquer dúvida.
                  </p>
                  <p>Vejo você na aula.</p>
                  <iframe src="./Assets/Validação com Express Validator - guia passo a passo.pdf" frameborder="0"></iframe>
               </display>
            </ao-vivo>

            <middlewares-ao-vivo>
               <h4>Middlewares [ao Vivo]</h4>
               <display>
                  <h1>Ponto de partida</h1>
                  <p>Como programadores, é importante aprendermos a utilizar middlewares, já que eles nos permitem projetar aplicações de forma mais eficiente.</p>
                  <h2>Quais são os objetivos dessa aula?</h2>
                  <ul>
                     <li>
                        <p>Compreender o que é e quando se utiliza um middleware.</p>
                     </li>
                     <li>
                        <p>Desenvolver um middleware.</p>
                     </li>
                  </ul>
                  <hr>
                  <iframe src="./Assets/Middlewares - prática integradora - traduzido.pdf" frameborder="0"></iframe>
                  <hr>
                  <h2>Arquivos para a prática middlewares - zip</h2>
                  <p><a href="./Assets/materiais-aula-middlewares (1).zip" download="">materiais-aula-middlewares (1).zip</a></p>
                  <h2>Prática resolvida middleware - zip</h2>
                  <p><a href="./Assets/exercicio-resolvido-middleware.zip" download="">exercicio-resolvido-middleware.zip</a></p>
               </display>
            </middlewares-ao-vivo>
            
         </middlewares>

         <sessions-e-cookies>
            <small>Sessions e Cookies</small>
            <intro>
               <h4>O que vamos ver nesta aula?</h4>
               <display>
                  <h1>O que vamos ver nesta aula?</h1>
                  <p>
                     Ao longo de nossas aulas, trabalhamos com um sistema que registra pessoas e armazena suas informações em um banco de dados do tipo JSON.
                  </p>
                  <p>
                     No entanto, até agora não pensamos no processo de login de uma pessoa que se cadastrou anteriormente. É exatamente nisso que vamos trabalhar nesta aula.
                  </p>
                  <p>Vamos aprender:</p>
                  <ul>
                     <li>
                        <p>O que é session e como podemos usá-lo.</p>
                     </li>
                     <li>
                        <p>O que são cookies e para que servem em nosso aplicativo.</p>
                     </li>
                     <li>
                        <p>Como criptografar informações confidenciais (como a senha) por meio de um processo de hashing.</p>
                     </li>
                     <li>
                        <p>Como construir um processo de login completo em nosso aplicativo.</p>
                     </li>
                  </ul>
                  <p>Com isso em mente, vamos mergulhar no maravilhoso mundo dos cookies e da session.</p>
                  <p>Vamos lá!</p>
               </display>
            </intro>
            
            <Session>
               <h4>Session</h4>
               <display>
                  <h1>Session</h1>
                  
               </display>
            </Session>
            
            <Cookies>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </Cookies>
            
            <Hashing>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </Hashing>
            
            <processo-de-login-completo>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </processo-de-login-completo>
            
            <Storytelling>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </Storytelling>
            
            <ao-vivo>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </ao-vivo>
            
            <material-para-download>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </material-para-download>
            
            <Sessions-e-Cookies-ao-vivo>
               <h4></h4>
               <display>
                  <h1></h1>
               </display>
            </Sessions-e-Cookies-ao-vivo>
            
         </sessions-e-cookies>
         
      </modulo>

   </body>
</html>

