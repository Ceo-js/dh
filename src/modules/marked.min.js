/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/marked@4.2.5/src/marked.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Lexer}from"./Lexer.js";import{Parser}from"./Parser.js";import{Tokenizer}from"./Tokenizer.js";import{Renderer}from"./Renderer.js";import{TextRenderer}from"./TextRenderer.js";import{Slugger}from"./Slugger.js";import{merge,checkSanitizeDeprecation,escape}from"./helpers.js";import{getDefaults,changeDefaults,defaults}from"./defaults.js";export function marked(e,r,t){if(null==e)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");if("function"==typeof r&&(t=r,r=null),r=merge({},marked.defaults,r||{}),checkSanitizeDeprecation(r),t){const n=r.highlight;let s;try{s=Lexer.lex(e,r)}catch(e){return t(e)}const o=function(e){let o;if(!e)try{r.walkTokens&&marked.walkTokens(s,r.walkTokens),o=Parser.parse(s,r)}catch(r){e=r}return r.highlight=n,e?t(e):t(null,o)};if(!n||n.length<3)return o();if(delete r.highlight,!s.length)return o();let a=0;return marked.walkTokens(s,(function(e){"code"===e.type&&(a++,setTimeout((()=>{n(e.text,e.lang,(function(r,t){if(r)return o(r);null!=t&&t!==e.text&&(e.text=t,e.escaped=!0),a--,0===a&&o()}))}),0))})),void(0===a&&o())}function n(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",r.silent)return"<p>An error occurred:</p><pre>"+escape(e.message+"",!0)+"</pre>";throw e}try{const t=Lexer.lex(e,r);if(r.walkTokens){if(r.async)return Promise.all(marked.walkTokens(t,r.walkTokens)).then((()=>Parser.parse(t,r))).catch(n);marked.walkTokens(t,r.walkTokens)}return Parser.parse(t,r)}catch(e){n(e)}}marked.options=marked.setOptions=function(e){return merge(marked.defaults,e),changeDefaults(marked.defaults),marked},marked.getDefaults=getDefaults,marked.defaults=defaults,marked.use=function(...e){const r=marked.defaults.extensions||{renderers:{},childTokens:{}};e.forEach((e=>{const t=merge({},e);if(t.async=marked.defaults.async||t.async,e.extensions&&(e.extensions.forEach((e=>{if(!e.name)throw new Error("extension name required");if(e.renderer){const t=r.renderers[e.name];r.renderers[e.name]=t?function(...r){let n=e.renderer.apply(this,r);return!1===n&&(n=t.apply(this,r)),n}:e.renderer}if(e.tokenizer){if(!e.level||"block"!==e.level&&"inline"!==e.level)throw new Error("extension level must be 'block' or 'inline'");r[e.level]?r[e.level].unshift(e.tokenizer):r[e.level]=[e.tokenizer],e.start&&("block"===e.level?r.startBlock?r.startBlock.push(e.start):r.startBlock=[e.start]:"inline"===e.level&&(r.startInline?r.startInline.push(e.start):r.startInline=[e.start]))}e.childTokens&&(r.childTokens[e.name]=e.childTokens)})),t.extensions=r),e.renderer){const r=marked.defaults.renderer||new Renderer;for(const t in e.renderer){const n=r[t];r[t]=(...s)=>{let o=e.renderer[t].apply(r,s);return!1===o&&(o=n.apply(r,s)),o}}t.renderer=r}if(e.tokenizer){const r=marked.defaults.tokenizer||new Tokenizer;for(const t in e.tokenizer){const n=r[t];r[t]=(...s)=>{let o=e.tokenizer[t].apply(r,s);return!1===o&&(o=n.apply(r,s)),o}}t.tokenizer=r}if(e.walkTokens){const r=marked.defaults.walkTokens;t.walkTokens=function(t){let n=[];return n.push(e.walkTokens.call(this,t)),r&&(n=n.concat(r.call(this,t))),n}}marked.setOptions(t)}))},marked.walkTokens=function(e,r){let t=[];for(const n of e)switch(t=t.concat(r.call(marked,n)),n.type){case"table":for(const e of n.header)t=t.concat(marked.walkTokens(e.tokens,r));for(const e of n.rows)for(const n of e)t=t.concat(marked.walkTokens(n.tokens,r));break;case"list":t=t.concat(marked.walkTokens(n.items,r));break;default:marked.defaults.extensions&&marked.defaults.extensions.childTokens&&marked.defaults.extensions.childTokens[n.type]?marked.defaults.extensions.childTokens[n.type].forEach((function(e){t=t.concat(marked.walkTokens(n[e],r))})):n.tokens&&(t=t.concat(marked.walkTokens(n.tokens,r)))}return t},marked.parseInline=function(e,r){if(null==e)throw new Error("marked.parseInline(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked.parseInline(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");r=merge({},marked.defaults,r||{}),checkSanitizeDeprecation(r);try{const t=Lexer.lexInline(e,r);return r.walkTokens&&marked.walkTokens(t,r.walkTokens),Parser.parseInline(t,r)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",r.silent)return"<p>An error occurred:</p><pre>"+escape(e.message+"",!0)+"</pre>";throw e}},marked.Parser=Parser,marked.parser=Parser.parse,marked.Renderer=Renderer,marked.TextRenderer=TextRenderer,marked.Lexer=Lexer,marked.lexer=Lexer.lex,marked.Tokenizer=Tokenizer,marked.Slugger=Slugger,marked.parse=marked;export const options=marked.options;export const setOptions=marked.setOptions;export const use=marked.use;export const walkTokens=marked.walkTokens;export const parseInline=marked.parseInline;export const parse=marked;export const parser=Parser.parse;export const lexer=Lexer.lex;export{defaults,getDefaults}from"./defaults.js";export{Lexer}from"./Lexer.js";export{Parser}from"./Parser.js";export{Tokenizer}from"./Tokenizer.js";export{Renderer}from"./Renderer.js";export{TextRenderer}from"./TextRenderer.js";export{Slugger}from"./Slugger.js";
//# sourceMappingURL=/sm/61b3f1703000463dcadb1b98be746dd3a186ec6f9b0f580367b40351b4c2406e.map